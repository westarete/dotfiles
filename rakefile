require 'net/ssh'

desc "usage. same as: rake"
task :default do
system "rake -T"
end

desc "deploy site to (beta | staging | production)"
task :deploy, [:projectname, :environment] => :verifyChef do | dp, args |
  (args[:projectname] and args[:environment]) ? nil : (puts "Incorrect arguments.\n #{Rake::Task['default'].invoke}\n#{fail(color("fail!\n", 'red'))}")
  verifyEnvironment( args[:environment] )
  /(([a-zA-Z0-9\-]+[.]{0,1})+[a-zA-Z0-9\-]*)+[.](org|com|net)*$/ =~ args[:projectname]
  cleanedProjectName = $1
  exists = checkForExistingServer( args[:environment], cleanedProjectName )
  if exists then
    puts color('exists', 'green')
    #checkForRoleUpdate(args[:environment], cleanedProjectName)
    pushNewRelease(args[:environment], cleanedProjectName, args[:projectname])
  else
    puts color('not yet', 'yellow')
    roleList = checkRequiredRoles(args[:environment], cleanedProjectName)
    puts "\'#{roleList}\'"
    system "cd #{ENV['WESTARETE']}/chef-repo; knife server create -e #{args[:environment]} -n #{cleanedProjectName} -b Y -r \'#{roleList}\'"
    exists = checkForExistingServer( args[:environment], cleanedProjectName )
    (exists) ? pushNewRelease(args[:environment], cleanedProjectName, args[:projectname]) : fail(color("error creating server.\n", 'red'))
  end
end

desc "destroy a site's server"
task :destroy, [:projectname, :environment] => :verifyChef do |ds, args|
  /(([a-zA-Z0-9\-]+[.]{0,1})+[a-zA-Z0-9\-]*)+[.](org|com|net)*$/ =~ args[:projectname]
  cleanedProjectName = $
  cleanedHost = args[:environment] + '.' + cleanedProjectName + '.westarete.com'
  puts "Are you sure you want to delete < #{cleanedHost} >? [Yn]"
  sure = STDIN.gets.strip
  if /[yY]([eE][sS])*/ =~ sure then
    system %& cd #{ENV['WESTARETE']}/chef-repo; knife server destroy -h \'#{cleanedHost}\' &
  else
    puts "site preserved."
  end
end

desc "list all chef-ed servers and roles"
task :list => :verifyChef do |l|
  nodeList = `cd #{ENV['WESTARETE']}/chef-repo; knife node list`.split
  nodeList.each do |node|
    nodeInfo = `cd #{ENV['WESTARETE']}/chef-repo; knife node show #{node}`.split("\n")
    nodeInfo = (nodeInfo.collect! { |r| r.scan(/[a-zA-Z.0-9\-]*$|\[[a-zA-Z\-]*\]/).join }).slice(0,5)
    print nodeInfo.join("\n\t"), "\n\n"
  end
end

desc "verify that chef is correctly installed and operational"
task :verifyChef do
  print "chef-repo:\t"
  if ENV['WESTARETE'] then
    if File.exists?("#{ENV['WESTARETE']}/chef-repo") then 
      puts color("OK", "green")
      verifyKnifeInstallation( "#{ENV['WESTARETE']}/chef-repo" )
    else
      fail("#{color('not found!', 'green')}\n Please clone/install the chef repo properly\n")
    end
  else
    puts color("not found!", "yellow")
    print "Would you like to set up your $WESTARETE environment variable temporarily? [Yn]: "
    setUp = (/[yY]/ =~ STDIN.gets.strip)
    (setUp) ? setUpWestAretePath : fail("Please set your $WESTARETE environment variable correctly\n")
  end
end

def pushNewRelease( environment, projectName, githubName )
  puts "deploying new site...."
  host = environment + "." + projectName + ".westarete.com"
  user = "deploy"
  remote_path = "/var/www/sites/#{host}"
  releaseTime = Time.new
  releaseFolder = releaseTime.year.to_s + releaseTime.month.to_s + releaseTime.day.to_s + releaseTime.hour.to_s + releaseTime.min.to_s + releaseTime.sec.to_s
  options = { :forward_agent => true }
  commands = [
    "ssh -T -o StrictHostKeyChecking=no git@github.com",
    "git clone git@github.com:westarete/#{githubName}.git #{remote_path}/releases/#{releaseFolder}",
    "if [ -f #{remote_path}/current ]; then rm #{remote_path}/current; fi",
    "ln -s #{remote_path}/releases/#{releaseFolder} #{remote_path}/current",
    "cd #{remote_path}/releases/#{releaseFolder}/; bundle install --without production",
    "sudo service apache2 restart"
  ]
  Net::SSH.start(host, user, options) do |ssh|
    commands.each { |line| puts ssh.exec!(line) }
    ssh.loop
  end
  puts color("done!", 'green')
end

def checkForRoleUpdate( environment, projectName )
  nodeName = environment + "." + projectName + ".westarete.com"
  currentRunList = `cd #{ENV['WESTARETE']}/chef-repo; knife node show #{nodeName}`.split("\n")[4]
  newRunListPosition = (/[ ][ ]+(.*)/ =~ currentRunList)
  newRunList = $1
  oldRunList = checkRequiredRoles( environment, projectName )
  print "role-update?:\t"
  if newRunList == oldRunList then
    puts "NO"
  else
    puts "YES"
    system %&cd #{ENV['WESTARETE']}/chef-repo; knife node run_list add #{nodeName} "#{newRunList}" &
  end
end

def checkRequiredRoles( environment, projectName)
  print "roles:\t\tsearching..."
  roles = []
  if ! File.exists?("#{ENV['WESTARETE']}/#{projectName}/Gemfile") then
    puts color("failed!", "yellow"), "\t No local project gemfile found!"
    puts "What roles/recipes would you like this project to have? [ie. role[webserver], recipe[postgre] ]"
    inputRoles = STDIN.gets.strip.split(/[ ]*,[ ]*/)
    verifyRoles( inputRoles )
    roles = inputRoles.join(", ")
  else
    puts "found gemfile. using: "
    gemfile = File.open("Gemfile", "r")
    gemText = gemfile.read
    gemfile.close
    rails = (/'rails'/ =~ gemText)
    postgres = (/'pg'/ =~ gemText)
    roles << (rails) ? "role[railsapp]" : nil
    roles <<  (postgres) ? "recipe[postgre]" : nil
    roles = roles.compact.join(", ")
    puts roles
  end
  roles
end

def verifyRoles( roleList )
  print "verifying roles..."
  availableRoles = `cd #{ENV['WESTARETE']}/chef-repo; knife role list`.split
  availableRecipes = `cd #{ENV['WESTARETE']}/chef-repo; knife cookbook list`.split("\n").collect! {|x| x.match(/[a-zA-Z\-]+/)[0]}
  roleList.each do |item|
    if( item.index('role') != nil ) then
      /[ ]*role\[(.*)\]/ =~ item
      name = $1
      if availableRoles.index(name) == nil then
        puts color("failed!", "red")
        fail("\t invalid role supplied. Available roles are:\n #{availableRoles}\n")
      end
    elsif (item.index('recipe') != nil ) then
      /[ ]*recipe\[(.*)\]/ =~ item
      name = $1
      index = nil
      if availableRecipes.index(name) == nil then
        puts color("failed!", "red")
        fail( "\t invalid recipe supplied. Available recipes are:\n #{availableRecipes}\n" )
      end
    else
      puts color("failed!", "red")
      fail( "invalid role/recipe in the role list provided.\nAvailable roles:\n#{availableRoles}\nAvailable recipes:\n#{availableRecipes}\n" )
    end
  end
  puts color("success!", "green")
end

def checkForExistingServer( environment, projectName )
  print "server:\t\t"
  serverSet = `cd #{ENV['WESTARETE']}/chef-repo; knife client list 2> /dev/null`.split
  deployServerName = environment + "." + projectName + ".westarete.com"
  exists = serverSet.index(deployServerName)
end

def setUpWestAretePath
  puts "enter the path to your westarete development folder:"
  location = STDIN.gets.strip
  location = (location[-1] == '/') ? location[0, location.length-1] : location
  ENV['WESTARETE']= location
  Rake::Task["verifyChef"].invoke
end

def verifyKnifeInstallation( location )
  print "knife:\t\t"
  currentLocale = ENV['PWD']
  output = `cd #{location}; knife client list 2> /dev/null`
  puts (/Check your configuration/ =~ output) ? fail("#{color('error!', 'red')}\nInstall knife properly.\n") : color("OK", "green")
end


def verifyEnvironment( purportedEnvironment )
  environments = %w{ beta staging production }
  print "environment:\t"
  if environments.index( purportedEnvironment ) then
    puts "#{purportedEnvironment}"
  else
    fail( "#{color('invalid!', 'red')} (beta, staging, production)\n" )
  end
end

def fail( reason )
  print reason
  exit 1
end

def color( text, color )
  colors = {
    :RED     => "\e[31m",
    :GREEN   => "\e[32m",
    :YELLOW  => "\e[33m",
    :BLUE    => "\e[34m",
    :MAGENTA => "\e[35m",
    :CYAN    => "\e[36m",
    :CLEAR   => "\e[0m"
  }
  output = "#{colors[color.upcase.intern]}#{text}#{colors[:CLEAR]}"
end

