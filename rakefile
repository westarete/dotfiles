require 'net/ssh'

desc "usage. same as: rake"
task :default do
  puts "usage: rake deploy[PROJECT,ENVIRONMENT]\n\tex. rake deploy[redi,beta] (!no spaces after comma!)"
end

desc "deploy site to (beta | staging | production)"
task :deploy, :projectname, :environment do | dp, args |
  verifyChef
  verifyEnvironment( args[:environment] )
  exists = checkForExistingServer( args[:environment], args[:projectname] )
  if exists then
    puts "exists"
    checkForRoleUpdate(args[:environment], args[:projectname])
    pushNewRelease(args[:environment], args[:projectname])
  else
    puts "not yet"
    roleList = checkRequiredRoles(args[:environment], args[:projectname])
    system "cd #{ENV['WESTARETE']}/chef-repo; knife server create -e #{args[:environment]} -n #{args[:projectname]} -b Y -r #{roleList}"
    exists = checkForExistingServer
    (exists) ? pushNewRelease(args[:environment], args[:projectname]) : fail("error creating server.\n")
  end
end


def pushNewRelease( environment, projectName )
  print "deploying new site...."
  host = environment + "." + projectName + ".westarete.com"
  user = "deploy"
  remote_path = "/var/www/sites/#{host}/releases/"
  releaseTime = Time.new
  releaseFolder = releaseTime.year.to_s + releaseTime.month.to_s + releaseTime.day.to_s + releaseTime.hour.to_s + releaseTime.min.to_s + releaseTime.sec.to_s
  options = { :forward_agent => 'true' }
  commands = [
    "git clone git@github.com:westarete/#{projectName}.git #{releaseFolder}",
    "rm /var/www/sites/#{host}/current",
    "ln -s /var/www/sites/#{host}/releases/#{releaseFolder} current",
    "sudo service apache2 restart"
  ]
  Net::SSH.start(host, user, options) do |ssh|
    commands.each { |line| puts ssh.exec!(line) }
    ssh.loop
  end
  puts "done!"
end

def checkForRoleUpdate( environment, projectName )
  print "role-update?:\t"
  nodeName = environment + "." + projectName + ".westarete.com"
  currentRunList = `cd #{ENV['WESTARETE']/chef-repo}; knife node show #{nodeName}`.split("\n")[4]
  newRunListPosition = (/[ ][ ]+(.*)/ =~ currentRoles)
  newRunList = $1
  oldRunList = checkRequiredRoles( environment, projectName )
  if newRunList == oldRunList then
    puts "NO"
  else
    puts "YES"
    system %&cd #{ENV['WESTARETE']/chef-repo}; knife node run_list add #{nodeName} "#{newRunList}" &
  end
end

def checkRequiredRoles( environment, projectName)
  print "roles:\t\tsearching..."
  roles = []
  if ! File.exists?("#{ENV['WESTARETE']}/#{projectName}/Gemfile") then
    puts "failed!\t No local project gemfile found!"
    puts "What roles/recipes would you like this project to have? [ie. 'role[webserver], recipe[postgre]' ]"
    inputRoles = STDIN.gets.strip.split(/[ ]*,[ ]*/)
    validateRoles( inputRoles )
    roles = inputRoles.join(", ")
  else
    puts "found gemfile. using: "
    gemfile = File.open("Gemfile", "r")
    gemText = gemfile.read
    gemfile.close
    rails = (/'rails'/ =~ gemText)
    postgres = (/'pg'/ =~ gemText)
    roles << (rails) ? "role[railsapp]" : nil
    roles <<  (postgres) ? "recipe[postgre]" : nil
    roles = roles.compact.join(", ")
    puts roles
  end
  roles
end

def validateRoles( roleList )
  print "validating roles..."
  availableRoles = `cd #{ENV['WESTARETE']/chef-repo}; knife role list`.split
  availableRecipes = `cd #{ENV['WESTARETE']/chef-repo}; knife cookbook list`.split("\n")
  roleList.each do |item|
    if( item.index('role') != nil ) then
      /[ ]*role\[(.*)\]/ =~ item
      name = $1
      if availableRoles.index(name) == nil then
        puts "failed!"
        fail("\t invalid role supplied. Available roles are:\n #{availableRoles}")
      end
    elsif (item.index('recipe') != nil ) then
      /[ ]*recipe\[(.*)\]/ =~ item
      name = $1
      index = nil
      availableRecipes.each do |avR|
        if avR.index(name) != nil then
          index = 'found'
        end
      end
      if index == nil then
        puts "failed!"
        fail( "\t invalid recipe supplied. Available recipes (ignore version numbers) are:\n #{availableRecipes}" )
      end
    else
      puts "failed!"
      fail( "invalid role/recipe in the role list provided.\nAvailable roles:\n#{availableRoles}\nAvailable recipes:\n#{availableRecipes}" )
    end
  end
end

def checkForExistingServer( environment, projectName )
  print "server:\t\t"
  serverSet = `cd #{ENV['WESTARETE']/chef-repo}; knife client list 2> /dev/null`.split
  deployServerName = environment + "." + projectName + ".westarete.com"
  exists = serverSet.index(deployServerName)
end

def verifyChef
  print "chef-repo:\t"
  if ENV['WESTARETE'] then
    if File.exists?("#{ENV['WESTARETE']}/chef-repo") then 
      puts "OK"
      verifyKnifeInstallation( "#{ENV['WESTARETE']}/chef-repo" )
    else
      fail("not found!\n Please clone/install the chef repo properly\n")
    end
  else
    puts "not found!"
    print "Would you like to set up your $WESTARETE environment variable temporarily? [Yn]: "
    setUp = (/[yY]/ =~ STDIN.gets.strip)
    (setUp) ? setUpWestAretePath : fail("Please set your $WESTARETE environment variable correctly\n")
  end
end

def setUpWestAretePath
  puts "enter the path to your westarete development folder:"
  location = STDIN.gets.strip
  location = (location[-1] == '/') ? location[0, location.length-1] : location
  ENV['WESTARETE']= location
  verifyChef
end

def verifyKnifeInstallation( location )
  print "knife:\t\t"
  currentLocale = ENV['PWD']
  output = `cd #{location}; knife client list 2> /dev/null`
  puts (/Check your configuration/ =~ output) ? fail("error!\nInstall knife properly.\n") : "OK"
end


def verifyEnvironment( purportedEnvironment )
  environments = %w{ beta staging production }
  print "environment:\t"
  if environments.index( purportedEnvironment ) then
    puts "#{purportedEnvironment}"
  else
    fail( "invalid! (beta, staging, production)\n" )
  end
end

def fail( reason )
  print "#{reason}"
  exit 1
end
